<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\cow as Exchange;
use ccxt\ExchangeError;
use ccxt\AuthenticationError;
use ccxt\ArgumentsRequired;
use ccxt\InvalidOrder;
use ccxt\NotSupported;
use ccxt\Precise;
use \React\Async;
use \React\Promise\PromiseInterface;

class cow extends Exchange {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'cow',
            'name' => 'CoW Protocol (Order Book API)',
            'countries' => array(),
            'rateLimit' => 500,
            'has' => array(
                'spot' => true,
                'fetchMarkets' => true,
                'createOrder' => true,      // POST /orders (signed body)
                'cancelOrder' => true,      // DELETE /orders (signed body)
                'fetchOrder' => true,       // GET /orders/{uid}
                'fetchOrders' => true,      // GET /account/{owner}/orders
                'fetchOpenOrders' => true,  // filtered from fetchOrders()
                'fetchMyTrades' => true,    // GET /trades?owner=... | orderUid=...
                // explicitly not supported by CoW:
                'fetchTicker' => false,
                'fetchTickers' => false,
                'fetchOrderBook' => false,
                'fetchTrades' => false,
                'fetchBalance' => false,
                'fetchCurrencies' => false,
            ),
            'requiredCredentials' => array(
                'apiKey' => false,
                'secret' => false,
                'uid' => false,
                'login' => false,
                'password' => false,
                'twofa' => false,
                'token' => false,
                'walletAddress' => true,
                'privateKey' => true,
            ),
            'urls' => array(
                // CCXT will pass this into your sign() â€“ compute the real base there
                'api' => 'https://api.cow.fi',
                'www' => 'https://cow.fi',
                'doc' => 'https://docs.cow.fi/cow-protocol/reference/apis/orderbook',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'api/v1/orders/{uid}' => 1,
                        'api/v1/trades' => 1,
                        'api/v1/account/{owner}/orders' => 1,
                    ),
                    'post' => array(
                        'api/v1/quote' => 12,
                        'api/v1/orders' => 1,
                    ),
                    'delete' => array(
                        'api/v1/orders' => 1,
                    ),
                ),
            ),
            'options' => array(
                // You can override these from user code => new \ccxt\cow(array( options => array( network => 'base', env => 'prod' )))
                'network' => 'mainnet', // 'mainnet' | 'xdai' | 'arbitrum_one' | 'base' | 'sepolia'
                'env' => 'prod',        // 'prod' | 'barn'
                'hosts' => array(
                    'prod' => 'https://api.cow.fi',
                    'barn' => 'https://barn.api.cow.fi',
                ),
                'networkIds' => array(
                    'mainnet' => 'mainnet',
                    'xdai' => 'xdai',
                    'arbitrum_one' => 'arbitrum-one',
                    'base' => 'base',
                    'sepolia' => 'sepolia',
                ),
                'defaultQuoteTokens' => array( 'USDC', 'USDT', 'DAI', 'WETH' ),
                'walletAddress' => null,
                'tokenListUrl' => 'https://files.cow.fi/tokens/CowSwap.json',
                'chainIds' => array(
                    'mainnet' => 1,
                    'xdai' => 100,
                    'arbitrum_one' => 42161,
                    'base' => 8453,
                    'sepolia' => 11155111,
                ),
                'verifyingContracts' => array(
                    'mainnet' => '0x9008d19f58aabd9ed0d60971565aa8510560ab41',
                    'xdai' => '0x9008d19f58aabd9ed0d60971565aa8510560ab41',
                    'arbitrum_one' => '0x9008d19f58aabd9ed0d60971565aa8510560ab41',
                    'base' => '0x9008d19f58aabd9ed0d60971565aa8510560ab41',
                    'sepolia' => '0x9008d19f58aabd9ed0d60971565aa8510560ab41',
                ),
                'defaultValidFor' => 30,
                'defaultAppData' => '0x0000000000000000000000000000000000000000000000000000000000000000',
                'defaultSigningScheme' => 'ethsign',
                'tokenBalances' => array(
                    'erc20' => 0,
                    'external' => 1,
                    'internal' => 2,
                ),
                'orderKinds' => array(
                    'sell' => 0,
                    'buy' => 1,
                ),
                'waitForOrder' => array(
                    'pollingDelay' => 2000,
                    'timeout' => 60000,
                    'statuses' => array( 'closed', 'canceled', 'expired', 'rejected' ),
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('0'),
                    'taker' => $this->parse_number('0'),
                ),
            ),
            'features' => array(
                'spot' => array(),
                'swap' => array(),
                'future' => array(),
                'option' => array(),
            ),
        ));
    }

    public function resolve_orderbook_base_url(?string $network = null, ?string $env = null): string {
        $defaultNetwork = $this->safe_string($this->options, 'network', 'mainnet');
        $selectedNetwork = ($network === null) ? $defaultNetwork : $network;
        $defaultEnv = $this->safe_string($this->options, 'env', 'prod');
        $selectedEnv = ($env === null) ? $defaultEnv : $env;
        $networkMap = $this->safe_value($this->options, 'networkIds', array());
        $networkId = $this->safe_string($networkMap, $selectedNetwork);
        if ($networkId === null) {
            throw new ExchangeError($this->id . ' resolveOrderbookBaseUrl() unsupported $network => ' . $selectedNetwork);
        }
        $hosts = $this->safe_value($this->options, 'hosts', array());
        $host = $this->safe_string($hosts, $selectedEnv);
        if ($host === null) {
            throw new ExchangeError($this->id . ' resolveOrderbookBaseUrl() unsupported environment => ' . $selectedEnv);
        }
        return $host . '/' . $networkId . '/api/v1';
    }

    public function sign($path, ?string $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $paramsWithoutPath = $this->omit($params, $this->extract_params($path));
        $network = $this->safe_string_2($paramsWithoutPath, 'network', 'chainId');
        $env = $this->safe_string($paramsWithoutPath, 'env');
        $query = $this->omit($paramsWithoutPath, array( 'network', 'chainId', 'env' ));
        $baseUrl = $this->resolve_orderbook_base_url($network, $env);
        $pathWithParams = $this->implode_params($path, $params);
        $versionPrefix = 'api/v1/';
        if (mb_strpos($pathWithParams, $versionPrefix) === 0) {
            $pathWithParams = $pathWithParams->substring (strlen($versionPrefix));
        }
        $url = $baseUrl;
        if (strlen($pathWithParams) > 0) {
            $url = $url . '/' . $pathWithParams;
        }
        if (($method === 'GET') || ($method === 'DELETE')) {
            if (!$this->is_empty($query)) {
                $url = $url . '?' . $this->urlencode($query);
            }
        } else {
            if (!$this->is_empty($query)) {
                $body = $this->json($query);
            }
            $headers = $this->extend(array(), $headers);
            $headers['Content-Type'] = 'application/json';
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function fetch_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            $parameters = $this->extend(array(), $params);
            $tokenListUrl = $this->safe_string($parameters, 'tokenListUrl', $this->safe_string($this->options, 'tokenListUrl', 'https://files.cow.fi/tokens/CowSwap.json'));
            $overrideTokens = $this->safe_list($parameters, 'tokens');
            $overrideQuotes = $this->safe_value($parameters, 'quoteSymbols');
            $overrideChainId = $this->safe_integer($parameters, 'chainId');
            $tokenList = null;
            if ($overrideTokens !== null) {
                $tokenList = array( 'tokens' => $overrideTokens );
            } else {
                $tokenList = Async\await($this->fetch($tokenListUrl, 'GET', null, null));
            }
            $tokens = $this->safe_list($tokenList, 'tokens', array());
            $targetChainId = ($overrideChainId === null) ? $this->get_chain_id_option() : $overrideChainId;
            $tokensBySymbol = array();
            for ($i = 0; $i < count($tokens); $i++) {
                $token = $tokens[$i];
                $chainId = $this->safe_integer($token, 'chainId');
                if (($chainId !== null) && ($chainId !== $targetChainId)) {
                    continue;
                }
                $symbol = $this->safe_string_upper($token, 'symbol');
                if ($symbol === null) {
                    continue;
                }
                $address = $this->safe_string_lower($token, 'address');
                if (!(is_array($tokensBySymbol) && array_key_exists($symbol, $tokensBySymbol))) {
                    $tokenRecord = $this->extend(array(), $token);
                    if ($address !== null) {
                        $tokenRecord['address'] = $address;
                    }
                    $tokensBySymbol[$symbol] = $tokenRecord;
                }
            }
            $defaultQuoteSymbols = $this->safe_value($this->options, 'defaultQuoteTokens', array( 'USDC', 'USDT', 'DAI', 'WETH' ));
            $quoteSymbolsRaw = ($overrideQuotes === null) ? $defaultQuoteSymbols : $overrideQuotes;
            $quoteSymbols => stringarray() = array();
            for ($i = 0; $i < count($quoteSymbolsRaw); $i++) {
                $quote = $quoteSymbolsRaw[$i];
                if ($quote !== null) {
                    $quoteSymbols[] = strtoupper($quote);
                }
            }
            $marketSymbols = is_array($tokensBySymbol) ? array_keys($tokensBySymbol) : array();
            $markets => Marketarray() = array();
            for ($i = 0; $i < count($marketSymbols); $i++) {
                $baseSymbol = $marketSymbols[$i];
                $baseToken = $tokensBySymbol[$baseSymbol];
                $baseAddress = $this->safe_string_lower($baseToken, 'address');
                if ($baseAddress === null) {
                    $baseAddress = strtolower($baseSymbol);
                }
                $baseDecimals = $this->safe_integer($baseToken, 'decimals');
                $amountPrecision = ($baseDecimals === null) ? null : $this->parse_number($this->parse_precision($this->number_to_string($baseDecimals)));
                for ($j = 0; $j < count($quoteSymbols); $j++) {
                    $quoteSymbolRaw = $quoteSymbols[$j];
                    if ($quoteSymbolRaw === null) {
                        continue;
                    }
                    $quoteSymbol = strtoupper($quoteSymbolRaw);
                    if ($baseSymbol === $quoteSymbol) {
                        continue;
                    }
                    $quoteToken = $this->safe_value($tokensBySymbol, $quoteSymbol);
                    if ($quoteToken === null) {
                        continue;
                    }
                    $quoteAddress = $this->safe_string_lower($quoteToken, 'address');
                    if ($quoteAddress === null) {
                        $quoteAddress = strtolower($quoteSymbol);
                    }
                    $baseCode = $this->safe_currency_code($baseSymbol);
                    $quoteCode = $this->safe_currency_code($quoteSymbol);
                    $symbol = $baseCode . '/' . $quoteCode;
                    $marketId = $baseAddress . '-' . $quoteAddress;
                    $markets[] = $this->safe_market_structure(array(
                        'id' => $marketId,
                        'uppercaseId' => null,
                        'symbol' => $symbol,
                        'base' => $baseCode,
                        'quote' => $quoteCode,
                        'baseId' => $baseAddress,
                        'quoteId' => $quoteAddress,
                        'type' => 'spot',
                        'spot' => true,
                        'margin' => false,
                        'swap' => false,
                        'future' => false,
                        'option' => false,
                        'taker' => $this->parse_number('0'),
                        'maker' => $this->parse_number('0'),
                        'contract' => false,
                        'linear' => null,
                        'inverse' => null,
                        'contractSize' => null,
                        'expiry' => null,
                        'expiryDatetime' => null,
                        'strike' => null,
                        'optionType' => null,
                        'settle' => null,
                        'settleId' => null,
                        'active' => true,
                        'limits' => array(
                            'amount' => array(
                                'min' => null,
                                'max' => null,
                            ),
                            'price' => array(
                                'min' => null,
                                'max' => null,
                            ),
                            'cost' => array(
                                'min' => null,
                                'max' => null,
                            ),
                            'leverage' => array(
                                'min' => null,
                                'max' => null,
                            ),
                        ),
                        'precision' => array(
                            'amount' => $amountPrecision,
                            'price' => null,
                        ),
                        'info' => array(
                            'base' => $baseToken,
                            'quote' => $quoteToken,
                        ),
                        'created' => null,
                    ));
                }
            }
            return $markets;
        }) ();
    }

    public function parse_trade(array $trade, ?array $market = null): array {
        $sellToken = $this->safe_string_lower($trade, 'sellToken');
        $buyToken = $this->safe_string_lower($trade, 'buyToken');
        $resolvedMarket = $market;
        if (($sellToken !== null) && ($buyToken !== null)) {
            $marketId = $sellToken . '-' . $buyToken;
            $resolvedMarket = $this->safe_market($marketId, $resolvedMarket, null, 'spot');
        }
        $resolvedMarket = $this->safe_market(null, $resolvedMarket, null, 'spot');
        $symbol = $this->safe_string($resolvedMarket, 'symbol');
        $marketInfo = $this->safe_value($resolvedMarket, 'info', array());
        $baseInfo = $this->safe_value($marketInfo, 'base', array());
        $quoteInfo = $this->safe_value($marketInfo, 'quote', array());
        $baseDecimals = $this->safe_string($baseInfo, 'decimals');
        $quoteDecimals = $this->safe_string($quoteInfo, 'decimals');
        $sellAmountRaw = $this->safe_string($trade, 'sellAmount');
        $buyAmountRaw = $this->safe_string($trade, 'buyAmount');
        $feeAmountRaw = $this->safe_string($trade, 'feeAmount');
        $kind = $this->safe_string_lower($trade, 'kind');
        $timestamp = $this->safe_integer($trade, 'timestamp');
        $orderUid = $this->safe_string($trade, 'orderUid');
        $tradeId = $this->safe_string($trade, 'tradeUid');
        $executedSellRaw = $this->safe_string($trade, 'executedSellAmount', $sellAmountRaw);
        $executedBuyRaw = $this->safe_string($trade, 'executedBuyAmount', $buyAmountRaw);
        $baseId = $this->safe_string_lower($resolvedMarket, 'baseId');
        $quoteId = $this->safe_string_lower($resolvedMarket, 'quoteId');
        $side => OrderSide = null;
        $amountRaw = null;
        $costRaw = null;
        if ($baseId === $sellToken) {
            $side = 'sell';
            $amountRaw = $executedSellRaw;
            $costRaw = $executedBuyRaw;
        } elseif ($baseId === $buyToken) {
            $side = 'buy';
            $amountRaw = $executedBuyRaw;
            $costRaw = $executedSellRaw;
        } elseif ($kind !== null) {
            if ($kind === 'buy') {
                $side = 'buy';
            } elseif ($kind === 'sell') {
                $side = 'sell';
            }
            $amountRaw = ($side === 'sell') ? $executedSellRaw : $executedBuyRaw;
            $costRaw = ($side === 'sell') ? $executedBuyRaw : $executedSellRaw;
        } else {
            $amountRaw = $executedSellRaw;
            $costRaw = $executedBuyRaw;
        }
        $amountString = $this->convert_token_amount($amountRaw, $baseDecimals);
        $costString = $this->convert_token_amount($costRaw, $quoteDecimals);
        $price = null;
        if (($amountString !== null) && ($costString !== null) && (!Precise::string_eq($amountString, '0'))) {
            $price = $this->parse_number(Precise::string_div($costString, $amountString));
        }
        $amount = $this->parse_number($amountString);
        $cost = $this->parse_number($costString);
        $fee = null;
        if ($feeAmountRaw !== null) {
            $feeCurrencyId = $this->safe_string_lower($trade, 'feeToken');
            if ($feeCurrencyId === null) {
                $feeCurrencyId = $sellToken;
            }
            $feeCurrencyCode = null;
            if ($feeCurrencyId === $baseId) {
                $feeCurrencyCode = $resolvedMarket['base'];
            } elseif ($feeCurrencyId === $quoteId) {
                $feeCurrencyCode = $resolvedMarket['quote'];
            } else {
                $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            }
            $feeDecimals = ($feeCurrencyId === $baseId) ? $baseDecimals : $quoteDecimals;
            $feeCost = $this->parse_number($this->convert_token_amount($feeAmountRaw, $feeDecimals));
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        $takerOrMaker = null;
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $tradeId,
            'order' => $orderUid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => null,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'takerOrMaker' => $takerOrMaker,
            'fee' => $fee,
        ), $resolvedMarket);
    }

    public function parse_order_status(?string $status) {
        $statuses = array(
            'open' => 'open',
            'pending' => 'open',
            'pending-solver-submission' => 'open',
            'presignatureAwaiting' => 'open',
            'presignaturePending' => 'open',
            'fulfilled' => 'closed',
            'expired' => 'expired',
            'solved' => 'closed',
            'cancelled' => 'canceled',
            'canceled' => 'canceled',
            'retracted' => 'canceled',
            'failed' => 'rejected',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function convert_token_amount(?string $amount, ?string $decimals) {
        if (($amount === null) || ($decimals === null)) {
            return null;
        }
        $decimalsString = (string) $decimals;
        $precision = $this->parse_precision($decimalsString);
        return Precise::string_mul($amount, $precision);
    }

    public function parse_order(array $order, ?array $market = null): array {
        $sellToken = $this->safe_string_lower($order, 'sellToken');
        $buyToken = $this->safe_string_lower($order, 'buyToken');
        $kind = $this->safe_string_lower($order, 'kind');
        $side => OrderSide = null;
        if ($kind !== null) {
            if ($kind === 'sell') {
                $side = 'sell';
            } elseif ($kind === 'buy') {
                $side = 'buy';
            }
        }
        $resolvedMarket = $market;
        if ($resolvedMarket === null) {
            if (($sellToken !== null) && ($buyToken !== null)) {
                $directId = $sellToken . '-' . $buyToken;
                $inverseId = $buyToken . '-' . $sellToken;
                $directMarket = $this->safe_value($this->markets_by_id, $directId);
                $inverseMarket = $this->safe_value($this->markets_by_id, $inverseId);
                if (($side === 'sell') && ($directMarket !== null)) {
                    $resolvedMarket = $directMarket;
                } elseif (($side === 'buy') && ($inverseMarket !== null)) {
                    $resolvedMarket = $inverseMarket;
                } elseif ($directMarket !== null) {
                    $resolvedMarket = $directMarket;
                } elseif ($inverseMarket !== null) {
                    $resolvedMarket = $inverseMarket;
                }
            }
        }
        $resolvedMarket = $this->safe_market(null, $resolvedMarket, null, 'spot');
        $symbol = $this->safe_string($resolvedMarket, 'symbol');
        $baseId = $this->safe_string($resolvedMarket, 'baseId');
        $quoteId = $this->safe_string($resolvedMarket, 'quoteId');
        $baseCurrency = $this->safe_string($resolvedMarket, 'base');
        $quoteCurrency = $this->safe_string($resolvedMarket, 'quote');
        if ($side === null) {
            if (($resolvedMarket !== null) && ($sellToken !== null) && ($buyToken !== null)) {
                if (($baseId === $sellToken) && ($quoteId === $buyToken)) {
                    $side = 'sell';
                } elseif (($baseId === $buyToken) && ($quoteId === $sellToken)) {
                    $side = 'buy';
                }
            }
        }
        $marketInfo = $this->safe_value($resolvedMarket, 'info', array());
        $infoBase = $this->safe_value($marketInfo, 'base', array());
        $infoQuote = $this->safe_value($marketInfo, 'quote', array());
        $baseDecimals = $this->safe_string($infoBase, 'decimals');
        $quoteDecimals = $this->safe_string($infoQuote, 'decimals');
        $sellAmountRaw = $this->safe_string($order, 'sellAmount');
        $buyAmountRaw = $this->safe_string($order, 'buyAmount');
        $executedSellRaw = $this->safe_string($order, 'executedSellAmount');
        $executedBuyRaw = $this->safe_string($order, 'executedBuyAmount');
        $amountRaw = null;
        $filledRaw = null;
        $costRaw = null;
        $baseDecimalsUsed = $baseDecimals;
        $quoteDecimalsUsed = $quoteDecimals;
        if ($side === 'sell') {
            $amountRaw = $sellAmountRaw;
            $filledRaw = $executedSellRaw;
            $costRaw = $executedBuyRaw;
        } elseif ($side === 'buy') {
            $amountRaw = $buyAmountRaw;
            $filledRaw = $executedBuyRaw;
            $costRaw = $executedSellRaw;
        } else {
            $amountRaw = $sellAmountRaw;
            $filledRaw = $executedSellRaw;
            $costRaw = $executedBuyRaw;
            if (($baseId === $buyToken) && ($quoteId === $sellToken)) {
                $baseDecimalsUsed = $quoteDecimals;
                $quoteDecimalsUsed = $baseDecimals;
            }
        }
        $amount = null;
        $filled = null;
        $cost = null;
        $remaining = null;
        $costString = null;
        $amountString = $this->convert_token_amount($amountRaw, $baseDecimalsUsed);
        $filledString = $this->convert_token_amount($filledRaw, $baseDecimalsUsed);
        $costString = $this->convert_token_amount($costRaw, $quoteDecimalsUsed);
        if ($amountString !== null) {
            $amount = $this->parse_number($amountString);
        }
        if ($filledString !== null) {
            $filled = $this->parse_number($filledString);
        }
        if ($amountRaw !== null && $filledRaw !== null) {
            $remainingRaw = Precise::string_sub($amountRaw, $filledRaw);
            $remainingString = $this->convert_token_amount($remainingRaw, $baseDecimalsUsed);
            if ($remainingString !== null) {
                $remaining = $this->parse_number($remainingString);
            }
        }
        if ($costString !== null) {
            $cost = $this->parse_number($costString);
        }
        $price = null;
        if (($filledString !== null) && ($costString !== null) && (!Precise::string_eq($filledString, '0'))) {
            $price = $this->parse_number(Precise::string_div($costString, $filledString));
        }
        $feeAmountRaw = $this->safe_string($order, 'feeAmount');
        $fee = null;
        if ($feeAmountRaw !== null) {
            $feeDecimals = $baseDecimalsUsed;
            $feeCurrency = $baseCurrency;
            if ($side === 'buy') {
                $feeDecimals = $quoteDecimalsUsed;
                $feeCurrency = $quoteCurrency;
            }
            $feeAmountString = $this->convert_token_amount($feeAmountRaw, $feeDecimals);
            if ($feeAmountString !== null) {
                $fee = array(
                    'currency' => $feeCurrency,
                    'cost' => $this->parse_number($feeAmountString),
                );
            }
        }
        $statusRaw = $this->safe_string($order, 'status');
        $status = $this->parse_order_status($statusRaw);
        $timestamp = $this->parse8601($this->safe_string_2($order, 'creationDate', 'creationTime'));
        if ($timestamp === null) {
            $timestamp = $this->safe_integer_product($order, 'creationTime', 1000);
        }
        $validTo = $this->safe_integer($order, 'validTo');
        $expiry = ($validTo !== null) ? ($validTo * 1000) : null;
        $orderType => OrderType = null;
        $postOnly = null;
        $timeInForce = null;
        $clientOrderId = $this->safe_string($order, 'appData');
        $triggerPrice = null;
        $average = $price;
        $lastTradeTimestamp = $this->parse8601($this->safe_string($order, 'executionTime'));
        if ($lastTradeTimestamp === null) {
            $lastTradeTimestamp = $this->safe_integer_product($order, 'executionTime', 1000);
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string($order, 'uid'),
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'symbol' => $symbol,
            'type' => $orderType,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'stopPrice' => $triggerPrice,
            'average' => $average,
            'cost' => $cost,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining,
            'status' => $status,
            'fee' => $fee,
            'fees' => null,
            'trades' => null,
            'triggerPrice' => $triggerPrice,
            'expiry' => $expiry,
        ), $resolvedMarket);
    }

    public function fetch_order(?string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            Async\await($this->load_markets());
            $request = array(
                'uid' => $id,
            );
            $response = Async\await($this->publicGetApiV1OrdersUid ($this->extend($request, $params)));
            $order = $this->safe_dict($response, 'order', $response);
            return $this->parse_order($order, ($symbol !== null) ? $this->market($symbol) : null);
        }) ();
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $owner = null;
            list($owner, $params) = $this->ensure_owner_address($params);
            $request = array(
                'owner' => $owner,
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->publicGetApiV1AccountOwnerOrders ($this->extend($request, $params)));
            $rawOrders = $this->safe_list($response, 'orders', $response);
            $parsedOrders = $this->parse_orders($rawOrders, $market, $since, $limit);
            return $this->filter_by_symbol_since_limit($parsedOrders, $symbol, $since, $limit);
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            $orders = Async\await($this->fetch_orders($symbol, $since, $limit, $params));
            return $this->filter_by($orders, 'status', 'open');
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $owner = null;
            list($owner, $params) = $this->ensure_owner_address($params);
            $request = array(
                'owner' => $owner,
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            if ($since !== null) {
                $request['minTimestamp'] = $since;
            }
            $response = Async\await($this->publicGetApiV1Trades ($this->extend($request, $params)));
            $trades = $this->parse_trades($response, $market, $since, $limit);
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit);
        }) ();
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $this->check_required_credentials();
            if (($this->privateKey === null) || ($this->privateKey === '')) {
                throw new AuthenticationError($this->id . ' createOrder() requires exchange.privateKey to be set');
            }
            $owner = null;
            list($owner, $params) = $this->ensure_owner_address($params);
            $receiverParam = $this->safe_string_lower($params, 'receiver', $owner);
            $fromParam = $this->safe_string_lower($params, 'from', $owner);
            $params = $this->omit($params, array( 'receiver', 'from' ));
            $kind = $this->safe_string_lower($params, 'kind', ($side === 'sell') ? 'sell' : 'buy');
            if ($kind !== 'sell') {
                throw new NotSupported($this->id . ' createOrder() currently supports only sell-$kind orders');
            }
            if (($type !== 'limit') && ($type !== 'market')) {
                throw new NotSupported($this->id . ' createOrder() supports $market and limit order types');
            }
            if (($type === 'limit') && ($price === null)) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires a $price argument for limit orders');
            }
            $marketInfo = $this->safe_value($market, 'info', array());
            $baseInfo = $this->safe_value($marketInfo, 'base', array());
            $quoteInfo = $this->safe_value($marketInfo, 'quote', array());
            $baseDecimals = $this->safe_string($baseInfo, 'decimals');
            $quoteDecimals = $this->safe_string($quoteInfo, 'decimals');
            $partiallyFillable = $this->safe_bool($params, 'partiallyFillable', false);
            $validFor = $this->safe_integer($params, 'validFor', $this->safe_integer($this->options, 'defaultValidFor', 30));
            $currentSeconds = $this->seconds();
            $validTo = $this->safe_integer($params, 'validTo', $currentSeconds . $validFor);
            $appData = $this->safe_string($params, 'appData', $this->safe_string($this->options, 'defaultAppData'));
            $quoteRequestOverrides = $this->safe_dict($params, 'quoteRequest');
            $params = $this->omit($params, array( 'kind', 'partiallyFillable', 'validFor', 'validTo', 'appData', 'quoteRequest' ));
            $sellToken = $this->safe_string_lower($market, 'baseId');
            $buyToken = $this->safe_string_lower($market, 'quoteId');
            $amountString = $this->number_to_string($amount);
            $sellAmountRaw = $this->amount_to_token_amount($amountString, $baseDecimals);
            $receiverAddress = $this->address_with0x_prefix($receiverParam);
            $fromAddress = $this->address_with0x_prefix($fromParam);
            $quoteRequest = $this->extend(array(
                'sellToken' => $this->address_with0x_prefix($sellToken),
                'buyToken' => $this->address_with0x_prefix($buyToken),
                'receiver' => $receiverAddress,
                'from' => $fromAddress,
                'kind' => $kind,
                'validTo' => $validTo,
                'partiallyFillable' => $partiallyFillable,
                'sellTokenBalance' => 'erc20',
                'buyTokenBalance' => 'erc20',
            ), $quoteRequestOverrides);
            $quoteRequest['sellAmountBeforeFee'] = $this->safe_string($quoteRequest, 'sellAmountBeforeFee', $sellAmountRaw);
            if ($type === 'limit') {
                $priceString = $this->number_to_string($price);
                $costDecimal = Precise::string_mul($amountString, $priceString);
                $buyAmountRaw = $this->amount_to_token_amount($costDecimal, $quoteDecimals);
                $quoteRequest['buyAmountAfterFee'] = $this->safe_string($quoteRequest, 'buyAmountAfterFee', $buyAmountRaw);
            }
            $quoteResponse = Async\await($this->publicPostApiV1Quote ($quoteRequest));
            $quote = $this->safe_dict($quoteResponse, 'quote', $quoteResponse);
            $orderBody = array(
                'sellToken' => $this->address_with0x_prefix($this->safe_string($quote, 'sellToken', $sellToken)),
                'buyToken' => $this->address_with0x_prefix($this->safe_string($quote, 'buyToken', $buyToken)),
                'receiver' => $this->address_with0x_prefix($this->safe_string($quote, 'receiver', $receiverParam)),
                'sellAmount' => $this->safe_string($quote, 'sellAmount', $sellAmountRaw),
                'buyAmount' => $this->safe_string($quote, 'buyAmount', $this->safe_string($quoteRequest, 'buyAmountAfterFee')),
                'validTo' => $this->safe_integer($quote, 'validTo', $validTo),
                'appData' => $this->safe_string($quote, 'appData', $appData),
                'feeAmount' => $this->safe_string($quote, 'feeAmount', '0'),
                'kind' => $this->safe_string_lower($quote, 'kind', $kind),
                'partiallyFillable' => $this->safe_bool($quote, 'partiallyFillable', $partiallyFillable),
                'sellTokenBalance' => $this->safe_string_lower($quote, 'sellTokenBalance', 'erc20'),
                'buyTokenBalance' => $this->safe_string_lower($quote, 'buyTokenBalance', 'erc20'),
                'signingScheme' => $this->safe_string($quote, 'signingScheme', $this->safe_string($this->options, 'defaultSigningScheme')),
                'from' => $this->address_with0x_prefix($this->safe_string($quote, 'from', $owner)),
            );
            $signature = $this->sign_order_payload($orderBody);
            $orderBody['signature'] = $signature;
            $response = Async\await($this->publicPostApiV1Orders ($orderBody));
            $uid = $this->safe_string_2($response, 'orderUid', 'uid');
            $parsed = $this->parse_order($this->extend(array(), $orderBody, array( 'uid' => $uid, 'info' => $response, 'status' => 'open' )), $market);
            return $this->extend($parsed, array( 'info' => $response ));
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            Async\await($this->load_markets());
            $this->check_required_credentials();
            if (($this->privateKey === null) || ($this->privateKey === '')) {
                throw new AuthenticationError($this->id . ' cancelOrder() requires exchange.privateKey to be set');
            }
            $owner = null;
            list($owner, $params) = $this->ensure_owner_address($params);
            $request = array(
                'orderUid' => $id,
            );
            $request['signature'] = $this->sign_order_cancellation($id);
            $request['signingScheme'] = $this->safe_string($params, 'signingScheme', $this->safe_string($this->options, 'defaultSigningScheme'));
            $params = $this->omit($params, array( 'signingScheme' ));
            $response = Async\await($this->publicDeleteApiV1Orders ($this->extend($request, $params)));
            $market = ($symbol !== null) ? $this->market($symbol) : null;
            return $this->parse_order(array( 'uid' => $id, 'status' => 'canceled', 'info' => $response, 'owner' => $owner ), $market);
        }) ();
    }

    public function ensure_owner_address(array $params = array ()): array {
        $owner = $this->safe_string_lower_2($params, 'owner', 'walletAddress');
        $modifiedParams = $this->omit($params, array( 'owner', 'walletAddress' ));
        if ($owner === null) {
            $optionOwner = $this->safe_string_lower($this->options, 'walletAddress');
            if ($optionOwner !== null) {
                $owner = $optionOwner;
            } elseif (($this->walletAddress !== null) && (gettype($this->walletAddress) === 'string') && ($this->walletAddress !== '')) {
                $owner = strtolower($this->walletAddress);
            }
        }
        if ($owner === null) {
            throw new ArgumentsRequired($this->id . ' requires a wallet address; set exchange.walletAddress, exchange.options["walletAddress"] or provide $params["owner"]');
        }
        return array( $owner, $modifiedParams );
    }

    public function hex_with0x_prefix(?string $value): ?string {
        if ($value === null) {
            return $value;
        }
        return str_starts_with($value, '0x') ? strtolower($value) : ('0x' . strtolower($value));
    }

    public function address_with0x_prefix(?string $value): ?string {
        return $this->hex_with0x_prefix($value);
    }

    public function normalize_private_key(?string $privateKey): ?string {
        if ($privateKey === null) {
            return $privateKey;
        }
        return $this->hex_with0x_prefix($privateKey);
    }

    public function amount_to_token_amount(?string $amountString, ?string $decimals): ?string {
        if (($amountString === null) || ($decimals === null)) {
            return null;
        }
        $decimalsString = (string) $decimals;
        $precision = $this->parse_precision($decimalsString);
        return Precise::string_mul($amountString, $precision);
    }

    public function order_kind_to_enum(?string $kind) {
        $normalized = ($kind === null) ? 'sell' : strtolower($kind);
        $mapping = $this->safe_value($this->options, 'orderKinds', array());
        $value = $this->safe_integer($mapping, $normalized);
        if ($value === null) {
            throw new ExchangeError($this->id . ' order $kind ' . $kind . ' is not supported');
        }
        return $value;
    }

    public function order_balance_to_enum(?string $balance) {
        $normalized = ($balance === null) ? 'erc20' : strtolower($balance);
        $mapping = $this->safe_value($this->options, 'tokenBalances', array());
        $value = $this->safe_integer($mapping, $normalized);
        if ($value === null) {
            throw new ExchangeError($this->id . ' token $balance type ' . $balance . ' is not supported');
        }
        return $value;
    }

    public function get_chain_id_option() {
        $network = $this->safe_string($this->options, 'network', 'mainnet');
        $chains = $this->safe_value($this->options, 'chainIds', array());
        $chainId = $this->safe_integer($chains, $network);
        if ($chainId === null) {
            throw new ExchangeError($this->id . ' unsupported $network ' . $network . ' for chain id resolution');
        }
        return $chainId;
    }

    public function get_verifying_contract_option() {
        $network = $this->safe_string($this->options, 'network', 'mainnet');
        $contracts = $this->safe_value($this->options, 'verifyingContracts', array());
        $verifyingContract = $this->safe_string($contracts, $network);
        if ($verifyingContract === null) {
            throw new ExchangeError($this->id . ' unsupported $network ' . $network . ' for verifying contract resolution');
        }
        return $this->hex_with0x_prefix($verifyingContract);
    }

    public function compute_typed_data_digest(array $domain, array $types, array $message) {
        $encoded = $this->eth_encode_structured_data($domain, $types, $message);
        $digestBytes = keccak ($encoded);
        return '0x' . bin2hex($digestBytes);
    }

    public function pad_hex(?string $hexString, $length = 64) {
        $raw = $this->remove0x_prefix($hexString);
        return str_pad($raw, $length, '0', STR_PAD_LEFT);
    }

    public function sign_digest(?string $digest, ?string $privateKey) {
        $normalizedDigest = $this->remove0x_prefix($digest);
        $normalizedKey = $this->remove0x_prefix($privateKey);
        $signature = $this->ecdsa($normalizedDigest, $normalizedKey, 'secp256k1', null);
        $r = $this->pad_hex($signature['r']);
        $s = $this->pad_hex($signature['s']);
        $vValue = $signature['v'] + 27;
        $vHex = $vValue->toString (16).padStart (2, '0');
        return '0x' . $r . $s . $vHex;
    }

    public function sign_order_payload(array $order) {
        $privateKey = $this->normalize_private_key($this->privateKey);
        $chainId = $this->get_chain_id_option();
        $verifyingContract = $this->get_verifying_contract_option();
        $domain = array(
            'name' => 'Gnosis Protocol v2',
            'version' => '2',
            'chainId' => $chainId,
            'verifyingContract' => $verifyingContract,
        );
        $message = array(
            'sellToken' => $this->hex_with0x_prefix($order['sellToken']),
            'buyToken' => $this->hex_with0x_prefix($order['buyToken']),
            'receiver' => $this->hex_with0x_prefix($order['receiver']),
            'sellAmount' => $this->safe_string($order, 'sellAmount'),
            'buyAmount' => $this->safe_string($order, 'buyAmount'),
            'validTo' => $this->safe_integer($order, 'validTo'),
            'appData' => $this->hex_with0x_prefix($this->safe_string($order, 'appData')),
            'feeAmount' => $this->safe_string($order, 'feeAmount', '0'),
            'kind' => $this->order_kind_to_enum($this->safe_string_lower($order, 'kind')),
            'partiallyFillable' => $this->safe_bool($order, 'partiallyFillable', false),
            'sellTokenBalance' => $this->order_balance_to_enum($this->safe_string_lower($order, 'sellTokenBalance')),
            'buyTokenBalance' => $this->order_balance_to_enum($this->safe_string_lower($order, 'buyTokenBalance')),
        );
        $types = array(
            'Order' => array(
                array( 'name' => 'sellToken', 'type' => 'address' ),
                array( 'name' => 'buyToken', 'type' => 'address' ),
                array( 'name' => 'receiver', 'type' => 'address' ),
                array( 'name' => 'sellAmount', 'type' => 'uint256' ),
                array( 'name' => 'buyAmount', 'type' => 'uint256' ),
                array( 'name' => 'validTo', 'type' => 'uint32' ),
                array( 'name' => 'appData', 'type' => 'bytes32' ),
                array( 'name' => 'feeAmount', 'type' => 'uint256' ),
                array( 'name' => 'kind', 'type' => 'uint8' ),
                array( 'name' => 'partiallyFillable', 'type' => 'bool' ),
                array( 'name' => 'sellTokenBalance', 'type' => 'uint8' ),
                array( 'name' => 'buyTokenBalance', 'type' => 'uint8' ),
            ),
        );
        $digest = $this->compute_typed_data_digest($domain, $types, $message);
        return $this->sign_digest($digest, $privateKey);
    }

    public function sign_order_cancellation(?string $orderUid) {
        $privateKey = $this->normalize_private_key($this->privateKey);
        $chainId = $this->get_chain_id_option();
        $verifyingContract = $this->get_verifying_contract_option();
        $domain = array(
            'name' => 'Gnosis Protocol v2',
            'version' => '2',
            'chainId' => $chainId,
            'verifyingContract' => $verifyingContract,
        );
        $message = array(
            'orderUid' => $this->hex_with0x_prefix($orderUid),
        );
        $types = array(
            'OrderCancellation' => array(
                array( 'name' => 'orderUid', 'type' => 'bytes' ),
            ),
        );
        $digest = $this->compute_typed_data_digest($domain, $types, $message);
        return $this->sign_digest($digest, $privateKey);
    }

    public function compare_quote_with_other_exchanges(?string $symbol, float $amount, array $otherExchanges = [], $params = array ()) {
        return Async\async(function () use ($symbol, $amount, $otherExchanges, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketInfo = $this->safe_value($market, 'info', array());
            $baseInfo = $this->safe_value($marketInfo, 'base', array());
            $quoteInfo = $this->safe_value($marketInfo, 'quote', array());
            $baseDecimals = $this->safe_string($baseInfo, 'decimals');
            $quoteDecimals = $this->safe_string($quoteInfo, 'decimals');
            $owner = null;
            list($owner, $params) = $this->ensure_owner_address($params);
            $receiverParam = $this->safe_string_lower($params, 'receiver', $owner);
            $fromParam = $this->safe_string_lower($params, 'from', $owner);
            $amountString = $this->number_to_string($amount);
            $sellAmountRaw = $this->amount_to_token_amount($amountString, $baseDecimals);
            $nowSeconds = $this->seconds();
            $validFor = $this->safe_integer($params, 'validFor', $this->safe_integer($this->options, 'defaultValidFor', 30));
            $validTo = $this->safe_integer($params, 'validTo', $nowSeconds . $validFor);
            $params = $this->omit($params, array( 'validFor', 'validTo', 'receiver', 'from' ));
            $quoteRequest = $this->extend(array(
                'sellToken' => $this->address_with0x_prefix($market['baseId']),
                'buyToken' => $this->address_with0x_prefix($market['quoteId']),
                'sellAmountBeforeFee' => $sellAmountRaw,
                'receiver' => $this->address_with0x_prefix($receiverParam),
                'from' => $this->address_with0x_prefix($fromParam),
                'kind' => 'sell',
                'partiallyFillable' => false,
                'validTo' => $validTo,
                'sellTokenBalance' => 'erc20',
                'buyTokenBalance' => 'erc20',
            ), $params);
            $quoteResponse = Async\await($this->publicPostApiV1Quote ($quoteRequest));
            $quote = $this->safe_dict($quoteResponse, 'quote', $quoteResponse);
            $cowSellAmountRaw = $this->safe_string($quote, 'sellAmount', $sellAmountRaw);
            $cowBuyAmountRaw = $this->safe_string($quote, 'buyAmount');
            $cowFeeRaw = $this->safe_string($quote, 'feeAmount', '0');
            $cowBuyAmount = $this->convert_token_amount($cowBuyAmountRaw, $quoteDecimals);
            $effectiveAmount = $this->convert_token_amount($cowSellAmountRaw, $baseDecimals);
            $cowFee = $this->convert_token_amount($cowFeeRaw, $baseDecimals);
            $cowPrice = null;
            if (($cowBuyAmount !== null) && ($effectiveAmount !== null) && (!Precise::string_eq($effectiveAmount, '0'))) {
                $cowPrice = $this->parse_number(Precise::string_div($cowBuyAmount, $effectiveAmount));
            }
            $comparisons = array();
            for ($i = 0; $i < count($otherExchanges); $i++) {
                $exchange = $otherExchanges[$i];
                $comparison = array(
                    'exchange' => null,
                    'available' => null,
                    'cost' => null,
                    'price' => null,
                    'slippage' => null,
                    'error' => null,
                    'info' => null,
                );
                try {
                    if ($exchange === null) {
                        continue;
                    }
                    $comparison['exchange'] = $exchange->id;
                    if (($exchange->has !== null) && ($exchange->has['fetchOrderBook'] !== null) && !$exchange->has['fetchOrderBook']) {
                        $comparison['error'] = 'fetchOrderBook not supported';
                        $comparisons[] = $comparison;
                        continue;
                    }
                    Async\await($exchange->loadMarkets ());
                    $orderBook = Async\await($exchange->fetchOrderBook ($symbol));
                    $comparison['info'] = $orderBook;
                    $asks = $this->safe_list($orderBook, 'asks', $orderBook['asks']);
                    $remaining = $amountString;
                    $cost = '0';
                    $filled = '0';
                    for ($j = 0; $j < count($asks); $j++) {
                        $level = $asks[$j];
                        $price = $this->number_to_string($level[0]);
                        $size = $this->number_to_string($level[1]);
                        if (($price === null) || ($size === null)) {
                            continue;
                        }
                        if (Precise::string_le($remaining, '0')) {
                            break;
                        }
                        $tradeAmount = Precise::string_min($remaining, $size);
                        $cost = Precise::string_add($cost, Precise::string_mul($tradeAmount, $price));
                        $filled = Precise::string_add($filled, $tradeAmount);
                        $remaining = Precise::string_sub($remaining, $tradeAmount);
                    }
                    if (Precise::string_le($filled, '0')) {
                        $comparison['error'] = 'insufficient liquidity';
                        $comparisons[] = $comparison;
                        continue;
                    }
                    $filledNumber = $this->parse_number($filled);
                    $costNumber = $this->parse_number($cost);
                    $priceNumber = null;
                    if ($filledNumber !== null && $filledNumber > 0 && $costNumber !== null) {
                        $priceNumber = $costNumber / $filledNumber;
                    }
                    $slippage = null;
                    if (($cowPrice !== null) && ($priceNumber !== null) && ($cowPrice !== 0)) {
                        $slippage = ($priceNumber - $cowPrice) / $cowPrice;
                    }
                    $comparison = $this->extend($comparison, array(
                        'available' => $filledNumber,
                        'cost' => $costNumber,
                        'price' => $priceNumber,
                        'slippage' => $slippage,
                        'remaining' => $this->parse_number($remaining),
                    ));
                } catch (Exception $error) {
                    $comparison['error'] = ($error instanceof Error) ? $error->message : $this->json($error);
                }
                $comparisons[] = $comparison;
            }
            return array(
                'symbol' => $symbol,
                'amount' => $amount,
                'price' => $this->parse_number($cowPrice),
                'buyAmount' => $this->parse_number($cowBuyAmount),
                'sellAmount' => $this->parse_number($effectiveAmount),
                'fee' => $this->parse_number($cowFee),
                'info' => $quoteResponse,
                'comparisons' => $comparisons,
            );
        }) ();
    }

    public function wait_for_order(?string $id, ?string $symbol = null, ?string $status = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $status, $params) {
            Async\await($this->load_markets());
            $options = $this->safe_value($this->options, 'waitForOrder', array());
            $statuses = $this->safe_value($options, 'statuses', array( 'closed', 'canceled', 'expired', 'rejected' ));
            $targetStatuses = ($status === null) ? $statuses : array( $status );
            $defaultPollingDelay = $this->safe_integer($options, 'pollingDelay', 2000);
            $defaultTimeout = $this->safe_integer($options, 'timeout', 60000);
            $pollingDelay = $this->safe_integer($params, 'pollingDelay', $defaultPollingDelay);
            $timeout = $this->safe_integer($params, 'timeout', $defaultTimeout);
            $fetchParams = $this->omit($params, array( 'pollingDelay', 'timeout' ));
            $deadline = $this->milliseconds() . $timeout;
            // eslint-disable-next-line no-constant-condition
            while (true) {
                $order = Async\await($this->fetch_order($id, $symbol, $fetchParams));
                $orderStatus = $this->safe_string($order, 'status');
                if ($this->in_array($orderStatus, $targetStatuses)) {
                    return $order;
                }
                if ($this->milliseconds() > $deadline) {
                    throw new InvalidOrder($this->id . ' waitForOrder() timed out waiting for $order ' . $id . ' to reach $status ' . implode(',', $targetStatuses));
                }
                Async\await($this->sleep($pollingDelay));
            }
        }) ();
    }

    public function handle_errors(?int $httpCode, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        $errorType = $this->safe_string($response, 'errorType');
        if ($errorType !== null) {
            $description = $this->safe_string($response, 'description');
            $feedback = $this->id . ' ' . ($description === null ? $body : $description);
            $errors = array(
                'DuplicatedOrder' => '\\ccxt\\InvalidOrder',
                'OrderAlreadyExists' => '\\ccxt\\InvalidOrder',
                'InvalidOrder' => '\\ccxt\\InvalidOrder',
                'InsufficientFee' => '\\ccxt\\InvalidOrder',
                'InsufficientFunds' => '\\ccxt\\InsufficientFunds',
                'UnknownOrder' => '\\ccxt\\OrderNotFound',
                'OrderNotFound' => '\\ccxt\\OrderNotFound',
                'OrderExpired' => '\\ccxt\\OrderNotFound',
                'InvalidSignature' => '\\ccxt\\AuthenticationError',
                'UnsupportedSellToken' => '\\ccxt\\BadSymbol',
                'UnsupportedBuyToken' => '\\ccxt\\BadSymbol',
                'UnsupportedSigningScheme' => '\\ccxt\\AuthenticationError',
                'InvalidAppData' => '\\ccxt\\BadRequest',
                'SellAmountDoesNotCoverFee' => '\\ccxt\\InvalidOrder',
                'SlippageTooLarge' => '\\ccxt\\InvalidOrder',
                'NoLiquidity' => '\\ccxt\\InvalidOrder',
            );
            $Exception = $this->safe_value($errors, $errorType, '\\ccxt\\ExchangeError');
            throw new $Exception($feedback);
        }
        $errorsList = $this->safe_list($response, 'errors');
        if ($errorsList !== null) {
            for ($i = 0; $i < count($errorsList); $i++) {
                $error = $errorsList[$i];
                $type = $this->safe_string($error, 'errorType');
                if ($type !== null) {
                    $description = $this->safe_string($error, 'description');
                    $feedback = $this->id . ' ' . ($description === null ? $this->json($error) : $description);
                    $errors = array(
                        'DuplicatedOrder' => '\\ccxt\\InvalidOrder',
                        'InvalidOrder' => '\\ccxt\\InvalidOrder',
                        'InsufficientFee' => '\\ccxt\\InvalidOrder',
                        'InsufficientFunds' => '\\ccxt\\InsufficientFunds',
                        'UnsupportedSellToken' => '\\ccxt\\BadSymbol',
                        'UnsupportedBuyToken' => '\\ccxt\\BadSymbol',
                        'NoLiquidity' => '\\ccxt\\InvalidOrder',
                    );
                    $Exception = $this->safe_value($errors, $type, '\\ccxt\\ExchangeError');
                    throw new $Exception($feedback);
                }
            }
        }
        $status = $this->safe_string($response, 'status');
        if (($status !== null) && ($status !== 'success') && ($status !== 'ok')) {
            $description = $this->safe_string($response, 'description');
            $feedback = $this->id . ' ' . ($description === null ? $body : $description);
            throw new ExchangeError($feedback);
        }
    }
}
