# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.cow import ImplicitAPI
from ccxt.base.types import Any, Int, Market, Order, OrderSide, OrderType, Str, Trade
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class cow(Exchange, ImplicitAPI):

    def describe(self) -> Any:
        return self.deep_extend(super(cow, self).describe(), {
            'id': 'cow',
            'name': 'CoW Protocol(Order Book API)',
            'countries': [],
            'rateLimit': 500,
            'has': {
                'spot': True,
                'fetchMarkets': True,
                'createOrder': True,      # POST /orders(signed body)
                'cancelOrder': True,      # DELETE /orders(signed body)
                'fetchOrder': True,       # GET /orders/{uid}
                'fetchOrders': True,      # GET /account/{owner}/orders
                'fetchOpenOrders': True,  # filtered from fetchOrders()
                'fetchMyTrades': True,    # GET /trades?owner=... | orderUid=...
                # explicitly not supported by CoW:
                'fetchTicker': False,
                'fetchTickers': False,
                'fetchOrderBook': False,
                'fetchTrades': False,
                'fetchBalance': False,
                'fetchCurrencies': False,
            },
            'requiredCredentials': {
                'apiKey': False,
                'secret': False,
                'uid': False,
                'login': False,
                'password': False,
                'twofa': False,
                'token': False,
                'walletAddress': True,
                'privateKey': True,
            },
            'urls': {
                # CCXT will pass self into your sign() â€“ compute the real base there
                'api': 'https://api.cow.fi',
                'www': 'https://cow.fi',
                'doc': 'https://docs.cow.fi/cow-protocol/reference/apis/orderbook',
            },
            'api': {
                'public': {
                    'get': {
                        'api/v1/orders/{uid}': 1,
                        'api/v1/trades': 1,
                        'api/v1/account/{owner}/orders': 1,
                    },
                    'post': {
                        'api/v1/quote': 12,
                        'api/v1/orders': 1,
                    },
                    'delete': {
                        'api/v1/orders': 1,
                    },
                },
            },
            'options': {
                # You can override these from user code: new ccxt.cow({options: {network: 'base', env: 'prod'}})
                'network': 'mainnet',  # 'mainnet' | 'xdai' | 'arbitrum_one' | 'base' | 'sepolia'
                'env': 'prod',        # 'prod' | 'barn'
                'hosts': {
                    'prod': 'https://api.cow.fi',
                    'barn': 'https://barn.api.cow.fi',
                },
                'networkIds': {
                    'mainnet': 'mainnet',
                    'xdai': 'xdai',
                    'arbitrum_one': 'arbitrum-one',
                    'base': 'base',
                    'sepolia': 'sepolia',
                },
                'defaultQuoteTokens': ['USDC', 'USDT', 'DAI', 'WETH'],
                'walletAddress': None,
                'tokenListUrl': 'https://files.cow.fi/tokens/CowSwap.json',
                'chainIds': {
                    'mainnet': 1,
                    'xdai': 100,
                    'arbitrum_one': 42161,
                    'base': 8453,
                    'sepolia': 11155111,
                },
                'verifyingContracts': {
                    'mainnet': '0x9008d19f58aabd9ed0d60971565aa8510560ab41',
                    'xdai': '0x9008d19f58aabd9ed0d60971565aa8510560ab41',
                    'arbitrum_one': '0x9008d19f58aabd9ed0d60971565aa8510560ab41',
                    'base': '0x9008d19f58aabd9ed0d60971565aa8510560ab41',
                    'sepolia': '0x9008d19f58aabd9ed0d60971565aa8510560ab41',
                },
                'defaultValidFor': 30,
                'defaultAppData': '0x0000000000000000000000000000000000000000000000000000000000000000',
                'defaultSigningScheme': 'ethsign',
                'tokenBalances': {
                    'erc20': 0,
                    'external': 1,
                    'internal': 2,
                },
                'orderKinds': {
                    'sell': 0,
                    'buy': 1,
                },
                'waitForOrder': {
                    'pollingDelay': 2000,
                    'timeout': 60000,
                    'statuses': ['closed', 'canceled', 'expired', 'rejected'],
                },
            },
            'precisionMode': TICK_SIZE,
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': self.parse_number('0'),
                    'taker': self.parse_number('0'),
                },
            },
            'features': {
                'spot': {},
                'swap': {},
                'future': {},
                'option': {},
            },
        })

    def resolve_orderbook_base_url(self, network: Str = None, env: Str = None) -> str:
        defaultNetwork = self.safe_string(self.options, 'network', 'mainnet')
        selectedNetwork = defaultNetwork if (network is None) else network
        defaultEnv = self.safe_string(self.options, 'env', 'prod')
        selectedEnv = defaultEnv if (env is None) else env
        networkMap = self.safe_value(self.options, 'networkIds', {})
        networkId = self.safe_string(networkMap, selectedNetwork)
        if networkId is None:
            raise ExchangeError(self.id + ' resolveOrderbookBaseUrl() unsupported network: ' + selectedNetwork)
        hosts = self.safe_value(self.options, 'hosts', {})
        host = self.safe_string(hosts, selectedEnv)
        if host is None:
            raise ExchangeError(self.id + ' resolveOrderbookBaseUrl() unsupported environment: ' + selectedEnv)
        return host + '/' + networkId + '/api/v1'

    def sign(self, path, api: Str = 'public', method='GET', params={}, headers=None, body=None):
        paramsWithoutPath = self.omit(params, self.extract_params(path))
        network = self.safe_string_2(paramsWithoutPath, 'network', 'chainId')
        env = self.safe_string(paramsWithoutPath, 'env')
        query = self.omit(paramsWithoutPath, ['network', 'chainId', 'env'])
        baseUrl = self.resolve_orderbook_base_url(network, env)
        pathWithParams = self.implode_params(path, params)
        versionPrefix = 'api/v1/'
        if pathWithParams.find(versionPrefix) == 0:
            pathWithParams = pathWithParams.substring(len(versionPrefix))
        url = baseUrl
        if len(pathWithParams) > 0:
            url = url + '/' + pathWithParams
        if (method == 'GET') or (method == 'DELETE'):
            if not self.is_empty(query):
                url = url + '?' + self.urlencode(query)
        else:
            if not self.is_empty(query):
                body = self.json(query)
            headers = self.extend({}, headers)
            headers['Content-Type'] = 'application/json'
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    async def fetch_markets(self, params={}) -> List[Market]:
        parameters = self.extend({}, params)
        tokenListUrl = self.safe_string(parameters, 'tokenListUrl', self.safe_string(self.options, 'tokenListUrl', 'https://files.cow.fi/tokens/CowSwap.json'))
        overrideTokens = self.safe_list(parameters, 'tokens')
        overrideQuotes = self.safe_value(parameters, 'quoteSymbols')
        overrideChainId = self.safe_integer(parameters, 'chainId')
        tokenList: dict = None
        if overrideTokens is not None:
            tokenList = {'tokens': overrideTokens}
        else:
            tokenList = await self.fetch(tokenListUrl, 'GET', None, None)
        tokens = self.safe_list(tokenList, 'tokens', [])
        targetChainId = self.get_chain_id_option() if (overrideChainId is None) else overrideChainId
        tokensBySymbol: dict = {}
        for i in range(0, len(tokens)):
            token = tokens[i]
            chainId = self.safe_integer(token, 'chainId')
            if (chainId is not None) and (chainId != targetChainId):
                continue
            symbol = self.safe_string_upper(token, 'symbol')
            if symbol is None:
                continue
            address = self.safe_string_lower(token, 'address')
            if not (symbol in tokensBySymbol):
                tokenRecord = self.extend({}, token)
                if address is not None:
                    tokenRecord['address'] = address
                tokensBySymbol[symbol] = tokenRecord
        defaultQuoteSymbols = self.safe_value(self.options, 'defaultQuoteTokens', ['USDC', 'USDT', 'DAI', 'WETH'])
        quoteSymbolsRaw = defaultQuoteSymbols if (overrideQuotes is None) else overrideQuotes
        quoteSymbols: List[str] = []
        for i in range(0, len(quoteSymbolsRaw)):
            quote = quoteSymbolsRaw[i]
            if quote is not None:
                quoteSymbols.append(quote.upper())
        marketSymbols = list(tokensBySymbol.keys())
        markets: Market[] = []
        for i in range(0, len(marketSymbols)):
            baseSymbol = marketSymbols[i]
            baseToken = tokensBySymbol[baseSymbol]
            baseAddress = self.safe_string_lower(baseToken, 'address')
            if baseAddress is None:
                baseAddress = baseSymbol.lower()
            baseDecimals = self.safe_integer(baseToken, 'decimals')
            amountPrecision = None if (baseDecimals is None) else self.parse_number(self.parse_precision(self.number_to_string(baseDecimals)))
            for j in range(0, len(quoteSymbols)):
                quoteSymbolRaw = quoteSymbols[j]
                if quoteSymbolRaw is None:
                    continue
                quoteSymbol = quoteSymbolRaw.upper()
                if baseSymbol == quoteSymbol:
                    continue
                quoteToken = self.safe_value(tokensBySymbol, quoteSymbol)
                if quoteToken is None:
                    continue
                quoteAddress = self.safe_string_lower(quoteToken, 'address')
                if quoteAddress is None:
                    quoteAddress = quoteSymbol.lower()
                baseCode = self.safe_currency_code(baseSymbol)
                quoteCode = self.safe_currency_code(quoteSymbol)
                symbol = baseCode + '/' + quoteCode
                marketId = baseAddress + '-' + quoteAddress
                markets.append(self.safe_market_structure({
                    'id': marketId,
                    'uppercaseId': None,
                    'symbol': symbol,
                    'base': baseCode,
                    'quote': quoteCode,
                    'baseId': baseAddress,
                    'quoteId': quoteAddress,
                    'type': 'spot',
                    'spot': True,
                    'margin': False,
                    'swap': False,
                    'future': False,
                    'option': False,
                    'taker': self.parse_number('0'),
                    'maker': self.parse_number('0'),
                    'contract': False,
                    'linear': None,
                    'inverse': None,
                    'contractSize': None,
                    'expiry': None,
                    'expiryDatetime': None,
                    'strike': None,
                    'optionType': None,
                    'settle': None,
                    'settleId': None,
                    'active': True,
                    'limits': {
                        'amount': {
                            'min': None,
                            'max': None,
                        },
                        'price': {
                            'min': None,
                            'max': None,
                        },
                        'cost': {
                            'min': None,
                            'max': None,
                        },
                        'leverage': {
                            'min': None,
                            'max': None,
                        },
                    },
                    'precision': {
                        'amount': amountPrecision,
                        'price': None,
                    },
                    'info': {
                        'base': baseToken,
                        'quote': quoteToken,
                    },
                    'created': None,
                }))
        return markets

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        sellToken = self.safe_string_lower(trade, 'sellToken')
        buyToken = self.safe_string_lower(trade, 'buyToken')
        resolvedMarket = market
        if (sellToken is not None) and (buyToken is not None):
            marketId = sellToken + '-' + buyToken
            resolvedMarket = self.safe_market(marketId, resolvedMarket, None, 'spot')
        resolvedMarket = self.safe_market(None, resolvedMarket, None, 'spot')
        symbol = self.safe_string(resolvedMarket, 'symbol')
        marketInfo = self.safe_value(resolvedMarket, 'info', {})
        baseInfo = self.safe_value(marketInfo, 'base', {})
        quoteInfo = self.safe_value(marketInfo, 'quote', {})
        baseDecimals = self.safe_string(baseInfo, 'decimals')
        quoteDecimals = self.safe_string(quoteInfo, 'decimals')
        sellAmountRaw = self.safe_string(trade, 'sellAmount')
        buyAmountRaw = self.safe_string(trade, 'buyAmount')
        feeAmountRaw = self.safe_string(trade, 'feeAmount')
        kind = self.safe_string_lower(trade, 'kind')
        timestamp = self.safe_integer(trade, 'timestamp')
        orderUid = self.safe_string(trade, 'orderUid')
        tradeId = self.safe_string(trade, 'tradeUid')
        executedSellRaw = self.safe_string(trade, 'executedSellAmount', sellAmountRaw)
        executedBuyRaw = self.safe_string(trade, 'executedBuyAmount', buyAmountRaw)
        baseId = self.safe_string_lower(resolvedMarket, 'baseId')
        quoteId = self.safe_string_lower(resolvedMarket, 'quoteId')
        side: OrderSide = None
        amountRaw = None
        costRaw = None
        if baseId == sellToken:
            side = 'sell'
            amountRaw = executedSellRaw
            costRaw = executedBuyRaw
        elif baseId == buyToken:
            side = 'buy'
            amountRaw = executedBuyRaw
            costRaw = executedSellRaw
        elif kind is not None:
            if kind == 'buy':
                side = 'buy'
            elif kind == 'sell':
                side = 'sell'
            amountRaw = executedSellRaw if (side == 'sell') else executedBuyRaw
            costRaw = executedBuyRaw if (side == 'sell') else executedSellRaw
        else:
            amountRaw = executedSellRaw
            costRaw = executedBuyRaw
        amountString = self.convert_token_amount(amountRaw, baseDecimals)
        costString = self.convert_token_amount(costRaw, quoteDecimals)
        price = None
        if (amountString is not None) and (costString is not None) and (not Precise.string_eq(amountString, '0')):
            price = self.parse_number(Precise.string_div(costString, amountString))
        amount = self.parse_number(amountString)
        cost = self.parse_number(costString)
        fee = None
        if feeAmountRaw is not None:
            feeCurrencyId = self.safe_string_lower(trade, 'feeToken')
            if feeCurrencyId is None:
                feeCurrencyId = sellToken
            feeCurrencyCode = None
            if feeCurrencyId == baseId:
                feeCurrencyCode = resolvedMarket['base']
            elif feeCurrencyId == quoteId:
                feeCurrencyCode = resolvedMarket['quote']
            else:
                feeCurrencyCode = self.safe_currency_code(feeCurrencyId)
            feeDecimals = baseDecimals if (feeCurrencyId == baseId) else quoteDecimals
            feeCost = self.parse_number(self.convert_token_amount(feeAmountRaw, feeDecimals))
            fee = {
                'cost': feeCost,
                'currency': feeCurrencyCode,
            }
        takerOrMaker = None
        return self.safe_trade({
            'info': trade,
            'id': tradeId,
            'order': orderUid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': None,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'takerOrMaker': takerOrMaker,
            'fee': fee,
        }, resolvedMarket)

    def parse_order_status(self, status: Str):
        statuses: dict = {
            'open': 'open',
            'pending': 'open',
            'pending-solver-submission': 'open',
            'presignatureAwaiting': 'open',
            'presignaturePending': 'open',
            'fulfilled': 'closed',
            'expired': 'expired',
            'solved': 'closed',
            'cancelled': 'canceled',
            'canceled': 'canceled',
            'retracted': 'canceled',
            'failed': 'rejected',
        }
        return self.safe_string(statuses, status, status)

    def convert_token_amount(self, amount: Str, decimals: Str):
        if (amount is None) or (decimals is None):
            return None
        decimalsString = str(decimals)
        precision = self.parse_precision(decimalsString)
        return Precise.string_mul(amount, precision)

    def parse_order(self, order: dict, market: Market = None) -> Order:
        sellToken = self.safe_string_lower(order, 'sellToken')
        buyToken = self.safe_string_lower(order, 'buyToken')
        kind = self.safe_string_lower(order, 'kind')
        side: OrderSide = None
        if kind is not None:
            if kind == 'sell':
                side = 'sell'
            elif kind == 'buy':
                side = 'buy'
        resolvedMarket: Market = market
        if resolvedMarket is None:
            if (sellToken is not None) and (buyToken is not None):
                directId = sellToken + '-' + buyToken
                inverseId = buyToken + '-' + sellToken
                directMarket = self.safe_value(self.markets_by_id, directId)
                inverseMarket = self.safe_value(self.markets_by_id, inverseId)
                if (side == 'sell') and (directMarket is not None):
                    resolvedMarket = directMarket
                elif (side == 'buy') and (inverseMarket is not None):
                    resolvedMarket = inverseMarket
                elif directMarket is not None:
                    resolvedMarket = directMarket
                elif inverseMarket is not None:
                    resolvedMarket = inverseMarket
        resolvedMarket = self.safe_market(None, resolvedMarket, None, 'spot')
        symbol = self.safe_string(resolvedMarket, 'symbol')
        baseId = self.safe_string(resolvedMarket, 'baseId')
        quoteId = self.safe_string(resolvedMarket, 'quoteId')
        baseCurrency = self.safe_string(resolvedMarket, 'base')
        quoteCurrency = self.safe_string(resolvedMarket, 'quote')
        if side is None:
            if (resolvedMarket is not None) and (sellToken is not None) and (buyToken is not None):
                if (baseId == sellToken) and (quoteId == buyToken):
                    side = 'sell'
                elif (baseId == buyToken) and (quoteId == sellToken):
                    side = 'buy'
        marketInfo = self.safe_value(resolvedMarket, 'info', {})
        infoBase = self.safe_value(marketInfo, 'base', {})
        infoQuote = self.safe_value(marketInfo, 'quote', {})
        baseDecimals = self.safe_string(infoBase, 'decimals')
        quoteDecimals = self.safe_string(infoQuote, 'decimals')
        sellAmountRaw = self.safe_string(order, 'sellAmount')
        buyAmountRaw = self.safe_string(order, 'buyAmount')
        executedSellRaw = self.safe_string(order, 'executedSellAmount')
        executedBuyRaw = self.safe_string(order, 'executedBuyAmount')
        amountRaw = None
        filledRaw = None
        costRaw = None
        baseDecimalsUsed = baseDecimals
        quoteDecimalsUsed = quoteDecimals
        if side == 'sell':
            amountRaw = sellAmountRaw
            filledRaw = executedSellRaw
            costRaw = executedBuyRaw
        elif side == 'buy':
            amountRaw = buyAmountRaw
            filledRaw = executedBuyRaw
            costRaw = executedSellRaw
        else:
            amountRaw = sellAmountRaw
            filledRaw = executedSellRaw
            costRaw = executedBuyRaw
            if (baseId == buyToken) and (quoteId == sellToken):
                baseDecimalsUsed = quoteDecimals
                quoteDecimalsUsed = baseDecimals
        amount = None
        filled = None
        cost = None
        remaining = None
        costString = None
        amountString = self.convert_token_amount(amountRaw, baseDecimalsUsed)
        filledString = self.convert_token_amount(filledRaw, baseDecimalsUsed)
        costString = self.convert_token_amount(costRaw, quoteDecimalsUsed)
        if amountString is not None:
            amount = self.parse_number(amountString)
        if filledString is not None:
            filled = self.parse_number(filledString)
        if amountRaw is not None and filledRaw is not None:
            remainingRaw = Precise.string_sub(amountRaw, filledRaw)
            remainingString = self.convert_token_amount(remainingRaw, baseDecimalsUsed)
            if remainingString is not None:
                remaining = self.parse_number(remainingString)
        if costString is not None:
            cost = self.parse_number(costString)
        price = None
        if (filledString is not None) and (costString is not None) and (not Precise.string_eq(filledString, '0')):
            price = self.parse_number(Precise.string_div(costString, filledString))
        feeAmountRaw = self.safe_string(order, 'feeAmount')
        fee = None
        if feeAmountRaw is not None:
            feeDecimals = baseDecimalsUsed
            feeCurrency = baseCurrency
            if side == 'buy':
                feeDecimals = quoteDecimalsUsed
                feeCurrency = quoteCurrency
            feeAmountString = self.convert_token_amount(feeAmountRaw, feeDecimals)
            if feeAmountString is not None:
                fee = {
                    'currency': feeCurrency,
                    'cost': self.parse_number(feeAmountString),
                }
        statusRaw = self.safe_string(order, 'status')
        status = self.parse_order_status(statusRaw)
        timestamp = self.parse8601(self.safe_string_2(order, 'creationDate', 'creationTime'))
        if timestamp is None:
            timestamp = self.safe_integer_product(order, 'creationTime', 1000)
        validTo = self.safe_integer(order, 'validTo')
        expiry = (validTo * 1000) if (validTo is not None) else None
        orderType: OrderType = None
        postOnly = None
        timeInForce = None
        clientOrderId = self.safe_string(order, 'appData')
        triggerPrice = None
        average = price
        lastTradeTimestamp = self.parse8601(self.safe_string(order, 'executionTime'))
        if lastTradeTimestamp is None:
            lastTradeTimestamp = self.safe_integer_product(order, 'executionTime', 1000)
        return self.safe_order({
            'info': order,
            'id': self.safe_string(order, 'uid'),
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': lastTradeTimestamp,
            'symbol': symbol,
            'type': orderType,
            'timeInForce': timeInForce,
            'postOnly': postOnly,
            'side': side,
            'price': price,
            'stopPrice': triggerPrice,
            'average': average,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
            'fees': None,
            'trades': None,
            'triggerPrice': triggerPrice,
            'expiry': expiry,
        }, resolvedMarket)

    async def fetch_order(self, id: Str, symbol: Str = None, params={}) -> Order:
        await self.load_markets()
        request = {
            'uid': id,
        }
        response = await self.publicGetApiV1OrdersUid(self.extend(request, params))
        order = self.safe_dict(response, 'order', response)
        return self.market(symbol) if self.parse_order(order,(symbol is not None) else None)

    async def fetch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        await self.load_markets()
        market: Market = None
        if symbol is not None:
            market = self.market(symbol)
        owner: Str = None
        owner, params = self.ensure_owner_address(params)
        request: dict = {
            'owner': owner,
        }
        if limit is not None:
            request['limit'] = limit
        response = await self.publicGetApiV1AccountOwnerOrders(self.extend(request, params))
        rawOrders = self.safe_list(response, 'orders', response)
        parsedOrders = self.parse_orders(rawOrders, market, since, limit)
        return self.filter_by_symbol_since_limit(parsedOrders, symbol, since, limit)

    async def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        orders = await self.fetch_orders(symbol, since, limit, params)
        return self.filter_by(orders, 'status', 'open')

    async def fetch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        await self.load_markets()
        market: Market = None
        if symbol is not None:
            market = self.market(symbol)
        owner: Str = None
        owner, params = self.ensure_owner_address(params)
        request: dict = {
            'owner': owner,
        }
        if limit is not None:
            request['limit'] = limit
        if since is not None:
            request['minTimestamp'] = since
        response = await self.publicGetApiV1Trades(self.extend(request, params))
        trades = self.parse_trades(response, market, since, limit)
        return self.filter_by_symbol_since_limit(trades, symbol, since, limit)

    async def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: float = None, params={}) -> Order:
        await self.load_markets()
        market = self.market(symbol)
        self.check_required_credentials()
        if (self.privateKey is None) or (self.privateKey == ''):
            raise AuthenticationError(self.id + ' createOrder() requires exchange.privateKey to be set')
        owner: Str = None
        owner, params = self.ensure_owner_address(params)
        receiverParam = self.safe_string_lower(params, 'receiver', owner)
        fromParam = self.safe_string_lower(params, 'from', owner)
        params = self.omit(params, ['receiver', 'from'])
        kind = 'sell' if self.safe_string_lower(params, 'kind',(side == 'sell') else 'buy')
        if kind != 'sell':
            raise NotSupported(self.id + ' createOrder() currently supports only sell-kind orders')
        if (type != 'limit') and (type != 'market'):
            raise NotSupported(self.id + ' createOrder() supports market and limit order types')
        if (type == 'limit') and (price is None):
            raise ArgumentsRequired(self.id + ' createOrder() requires a price argument for limit orders')
        marketInfo = self.safe_value(market, 'info', {})
        baseInfo = self.safe_value(marketInfo, 'base', {})
        quoteInfo = self.safe_value(marketInfo, 'quote', {})
        baseDecimals = self.safe_string(baseInfo, 'decimals')
        quoteDecimals = self.safe_string(quoteInfo, 'decimals')
        partiallyFillable = self.safe_bool(params, 'partiallyFillable', False)
        validFor = self.safe_integer(params, 'validFor', self.safe_integer(self.options, 'defaultValidFor', 30))
        currentSeconds = self.seconds()
        validTo = self.safe_integer(params, 'validTo', currentSeconds + validFor)
        appData = self.safe_string(params, 'appData', self.safe_string(self.options, 'defaultAppData'))
        quoteRequestOverrides = self.safe_dict(params, 'quoteRequest')
        params = self.omit(params, ['kind', 'partiallyFillable', 'validFor', 'validTo', 'appData', 'quoteRequest'])
        sellToken = self.safe_string_lower(market, 'baseId')
        buyToken = self.safe_string_lower(market, 'quoteId')
        amountString = self.number_to_string(amount)
        sellAmountRaw = self.amount_to_token_amount(amountString, baseDecimals)
        receiverAddress = self.address_with0x_prefix(receiverParam)
        fromAddress = self.address_with0x_prefix(fromParam)
        quoteRequest: dict = self.extend({
            'sellToken': self.address_with0x_prefix(sellToken),
            'buyToken': self.address_with0x_prefix(buyToken),
            'receiver': receiverAddress,
            'from': fromAddress,
            'kind': kind,
            'validTo': validTo,
            'partiallyFillable': partiallyFillable,
            'sellTokenBalance': 'erc20',
            'buyTokenBalance': 'erc20',
        }, quoteRequestOverrides)
        quoteRequest['sellAmountBeforeFee'] = self.safe_string(quoteRequest, 'sellAmountBeforeFee', sellAmountRaw)
        if type == 'limit':
            priceString = self.number_to_string(price)
            costDecimal = Precise.string_mul(amountString, priceString)
            buyAmountRaw = self.amount_to_token_amount(costDecimal, quoteDecimals)
            quoteRequest['buyAmountAfterFee'] = self.safe_string(quoteRequest, 'buyAmountAfterFee', buyAmountRaw)
        quoteResponse = await self.publicPostApiV1Quote(quoteRequest)
        quote = self.safe_dict(quoteResponse, 'quote', quoteResponse)
        orderBody: dict = {
            'sellToken': self.address_with0x_prefix(self.safe_string(quote, 'sellToken', sellToken)),
            'buyToken': self.address_with0x_prefix(self.safe_string(quote, 'buyToken', buyToken)),
            'receiver': self.address_with0x_prefix(self.safe_string(quote, 'receiver', receiverParam)),
            'sellAmount': self.safe_string(quote, 'sellAmount', sellAmountRaw),
            'buyAmount': self.safe_string(quote, 'buyAmount', self.safe_string(quoteRequest, 'buyAmountAfterFee')),
            'validTo': self.safe_integer(quote, 'validTo', validTo),
            'appData': self.safe_string(quote, 'appData', appData),
            'feeAmount': self.safe_string(quote, 'feeAmount', '0'),
            'kind': self.safe_string_lower(quote, 'kind', kind),
            'partiallyFillable': self.safe_bool(quote, 'partiallyFillable', partiallyFillable),
            'sellTokenBalance': self.safe_string_lower(quote, 'sellTokenBalance', 'erc20'),
            'buyTokenBalance': self.safe_string_lower(quote, 'buyTokenBalance', 'erc20'),
            'signingScheme': self.safe_string(quote, 'signingScheme', self.safe_string(self.options, 'defaultSigningScheme')),
            'from': self.address_with0x_prefix(self.safe_string(quote, 'from', owner)),
        }
        signature = self.sign_order_payload(orderBody)
        orderBody['signature'] = signature
        response = await self.publicPostApiV1Orders(orderBody)
        uid = self.safe_string_2(response, 'orderUid', 'uid')
        parsed = self.parse_order(self.extend({}, orderBody, {'uid': uid, 'info': response, 'status': 'open'}), market)
        return self.extend(parsed, {'info': response})

    async def cancel_order(self, id: str, symbol: Str = None, params={}) -> Order:
        await self.load_markets()
        self.check_required_credentials()
        if (self.privateKey is None) or (self.privateKey == ''):
            raise AuthenticationError(self.id + ' cancelOrder() requires exchange.privateKey to be set')
        owner: Str = None
        owner, params = self.ensure_owner_address(params)
        request: dict = {
            'orderUid': id,
        }
        request['signature'] = self.sign_order_cancellation(id)
        request['signingScheme'] = self.safe_string(params, 'signingScheme', self.safe_string(self.options, 'defaultSigningScheme'))
        params = self.omit(params, ['signingScheme'])
        response = await self.publicDeleteApiV1Orders(self.extend(request, params))
        market = self.market(symbol) if (symbol is not None) else None
        return self.parse_order({'uid': id, 'status': 'canceled', 'info': response, 'owner': owner}, market)

    def ensure_owner_address(self, params: dict = {}) -> List[Any]:
        owner = self.safe_string_lower_2(params, 'owner', 'walletAddress')
        modifiedParams = self.omit(params, ['owner', 'walletAddress'])
        if owner is None:
            optionOwner = self.safe_string_lower(self.options, 'walletAddress')
            if optionOwner is not None:
                owner = optionOwner
            elif (self.walletAddress is not None) and (isinstance(self.walletAddress, str)) and (self.walletAddress != ''):
                owner = self.walletAddress.lower()
        if owner is None:
            raise ArgumentsRequired(self.id + ' requires a wallet address; set exchange.walletAddress, exchange.options["walletAddress"] or provide params["owner"]')
        return [owner, modifiedParams]

    def hex_with0x_prefix(self, value: Str) -> Str:
        if value is None:
            return value
        return value.lower() if value.startswith('0x') else ('0x' + value.lower())

    def address_with0x_prefix(self, value: Str) -> Str:
        return self.hex_with0x_prefix(value)

    def normalize_private_key(self, privateKey: Str) -> Str:
        if privateKey is None:
            return privateKey
        return self.hex_with0x_prefix(privateKey)

    def amount_to_token_amount(self, amountString: Str, decimals: Str) -> Str:
        if (amountString is None) or (decimals is None):
            return None
        decimalsString = str(decimals)
        precision = self.parse_precision(decimalsString)
        return Precise.string_mul(amountString, precision)

    def order_kind_to_enum(self, kind: Str):
        normalized = 'sell' if (kind is None) else kind.lower()
        mapping = self.safe_value(self.options, 'orderKinds', {})
        value = self.safe_integer(mapping, normalized)
        if value is None:
            raise ExchangeError(self.id + ' order kind ' + kind + ' is not supported')
        return value

    def order_balance_to_enum(self, balance: Str):
        normalized = 'erc20' if (balance is None) else balance.lower()
        mapping = self.safe_value(self.options, 'tokenBalances', {})
        value = self.safe_integer(mapping, normalized)
        if value is None:
            raise ExchangeError(self.id + ' token balance type ' + balance + ' is not supported')
        return value

    def get_chain_id_option(self):
        network = self.safe_string(self.options, 'network', 'mainnet')
        chains = self.safe_value(self.options, 'chainIds', {})
        chainId = self.safe_integer(chains, network)
        if chainId is None:
            raise ExchangeError(self.id + ' unsupported network ' + network + ' for chain id resolution')
        return chainId

    def get_verifying_contract_option(self):
        network = self.safe_string(self.options, 'network', 'mainnet')
        contracts = self.safe_value(self.options, 'verifyingContracts', {})
        verifyingContract = self.safe_string(contracts, network)
        if verifyingContract is None:
            raise ExchangeError(self.id + ' unsupported network ' + network + ' for verifying contract resolution')
        return self.hex_with0x_prefix(verifyingContract)

    def compute_typed_data_digest(self, domain: dict, types: dict, message: dict):
        encoded = self.eth_encode_structured_data(domain, types, message)
        digestBytes = keccak(encoded)
        return '0x' + self.binary_to_base16(digestBytes)

    def pad_hex(self, hexString: Str, length=64):
        raw = self.remove0x_prefix(hexString)
        return raw.rjust(length, '0')

    def sign_digest(self, digest: Str, privateKey: Str):
        normalizedDigest = self.remove0x_prefix(digest)
        normalizedKey = self.remove0x_prefix(privateKey)
        signature = self.ecdsa(normalizedDigest, normalizedKey, 'secp256k1', None)
        r = self.pad_hex(signature['r'])
        s = self.pad_hex(signature['s'])
        vValue = signature['v'] + 27
        vHex = vValue.toString(16).rjust(2, '0')
        return '0x' + r + s + vHex

    def sign_order_payload(self, order: dict):
        privateKey = self.normalize_private_key(self.privateKey)
        chainId = self.get_chain_id_option()
        verifyingContract = self.get_verifying_contract_option()
        domain = {
            'name': 'Gnosis Protocol v2',
            'version': '2',
            'chainId': chainId,
            'verifyingContract': verifyingContract,
        }
        message = {
            'sellToken': self.hex_with0x_prefix(order['sellToken']),
            'buyToken': self.hex_with0x_prefix(order['buyToken']),
            'receiver': self.hex_with0x_prefix(order['receiver']),
            'sellAmount': self.safe_string(order, 'sellAmount'),
            'buyAmount': self.safe_string(order, 'buyAmount'),
            'validTo': self.safe_integer(order, 'validTo'),
            'appData': self.hex_with0x_prefix(self.safe_string(order, 'appData')),
            'feeAmount': self.safe_string(order, 'feeAmount', '0'),
            'kind': self.order_kind_to_enum(self.safe_string_lower(order, 'kind')),
            'partiallyFillable': self.safe_bool(order, 'partiallyFillable', False),
            'sellTokenBalance': self.order_balance_to_enum(self.safe_string_lower(order, 'sellTokenBalance')),
            'buyTokenBalance': self.order_balance_to_enum(self.safe_string_lower(order, 'buyTokenBalance')),
        }
        types = {
            'Order': [
                {'name': 'sellToken', 'type': 'address'},
                {'name': 'buyToken', 'type': 'address'},
                {'name': 'receiver', 'type': 'address'},
                {'name': 'sellAmount', 'type': 'uint256'},
                {'name': 'buyAmount', 'type': 'uint256'},
                {'name': 'validTo', 'type': 'uint32'},
                {'name': 'appData', 'type': 'bytes32'},
                {'name': 'feeAmount', 'type': 'uint256'},
                {'name': 'kind', 'type': 'uint8'},
                {'name': 'partiallyFillable', 'type': 'bool'},
                {'name': 'sellTokenBalance', 'type': 'uint8'},
                {'name': 'buyTokenBalance', 'type': 'uint8'},
            ],
        }
        digest = self.compute_typed_data_digest(domain, types, message)
        return self.sign_digest(digest, privateKey)

    def sign_order_cancellation(self, orderUid: Str):
        privateKey = self.normalize_private_key(self.privateKey)
        chainId = self.get_chain_id_option()
        verifyingContract = self.get_verifying_contract_option()
        domain = {
            'name': 'Gnosis Protocol v2',
            'version': '2',
            'chainId': chainId,
            'verifyingContract': verifyingContract,
        }
        message = {
            'orderUid': self.hex_with0x_prefix(orderUid),
        }
        types = {
            'OrderCancellation': [
                {'name': 'orderUid', 'type': 'bytes'},
            ],
        }
        digest = self.compute_typed_data_digest(domain, types, message)
        return self.sign_digest(digest, privateKey)

    async def compare_quote_with_other_exchanges(self, symbol: Str, amount: float, otherExchanges: List[Any] = [], params={}):
        await self.load_markets()
        market = self.market(symbol)
        marketInfo = self.safe_value(market, 'info', {})
        baseInfo = self.safe_value(marketInfo, 'base', {})
        quoteInfo = self.safe_value(marketInfo, 'quote', {})
        baseDecimals = self.safe_string(baseInfo, 'decimals')
        quoteDecimals = self.safe_string(quoteInfo, 'decimals')
        owner: Str = None
        owner, params = self.ensure_owner_address(params)
        receiverParam = self.safe_string_lower(params, 'receiver', owner)
        fromParam = self.safe_string_lower(params, 'from', owner)
        amountString = self.number_to_string(amount)
        sellAmountRaw = self.amount_to_token_amount(amountString, baseDecimals)
        nowSeconds = self.seconds()
        validFor = self.safe_integer(params, 'validFor', self.safe_integer(self.options, 'defaultValidFor', 30))
        validTo = self.safe_integer(params, 'validTo', nowSeconds + validFor)
        params = self.omit(params, ['validFor', 'validTo', 'receiver', 'from'])
        quoteRequest = self.extend({
            'sellToken': self.address_with0x_prefix(market['baseId']),
            'buyToken': self.address_with0x_prefix(market['quoteId']),
            'sellAmountBeforeFee': sellAmountRaw,
            'receiver': self.address_with0x_prefix(receiverParam),
            'from': self.address_with0x_prefix(fromParam),
            'kind': 'sell',
            'partiallyFillable': False,
            'validTo': validTo,
            'sellTokenBalance': 'erc20',
            'buyTokenBalance': 'erc20',
        }, params)
        quoteResponse = await self.publicPostApiV1Quote(quoteRequest)
        quote = self.safe_dict(quoteResponse, 'quote', quoteResponse)
        cowSellAmountRaw = self.safe_string(quote, 'sellAmount', sellAmountRaw)
        cowBuyAmountRaw = self.safe_string(quote, 'buyAmount')
        cowFeeRaw = self.safe_string(quote, 'feeAmount', '0')
        cowBuyAmount = self.convert_token_amount(cowBuyAmountRaw, quoteDecimals)
        effectiveAmount = self.convert_token_amount(cowSellAmountRaw, baseDecimals)
        cowFee = self.convert_token_amount(cowFeeRaw, baseDecimals)
        cowPrice = None
        if (cowBuyAmount is not None) and (effectiveAmount is not None) and (not Precise.string_eq(effectiveAmount, '0')):
            cowPrice = self.parse_number(Precise.string_div(cowBuyAmount, effectiveAmount))
        comparisons = []
        for i in range(0, len(otherExchanges)):
            exchange = otherExchanges[i]
            comparison = {
                'exchange': None,
                'available': None,
                'cost': None,
                'price': None,
                'slippage': None,
                'error': None,
                'info': None,
            }
            try:
                if exchange is None:
                    continue
                comparison['exchange'] = exchange.id
                if (exchange.has is not None) and (exchange.has['fetchOrderBook'] is not None) and not exchange.has['fetchOrderBook']:
                    comparison['error'] = 'fetchOrderBook not supported'
                    comparisons.append(comparison)
                    continue
                await exchange.loadMarkets()
                orderBook = await exchange.fetchOrderBook(symbol)
                comparison['info'] = orderBook
                asks = self.safe_list(orderBook, 'asks', orderBook['asks'])
                remaining = amountString
                cost = '0'
                filled = '0'
                for j in range(0, len(asks)):
                    level = asks[j]
                    price = self.number_to_string(level[0])
                    size = self.number_to_string(level[1])
                    if (price is None) or (size is None):
                        continue
                    if Precise.string_le(remaining, '0'):
                        break
                    tradeAmount = Precise.string_min(remaining, size)
                    cost = Precise.string_add(cost, Precise.string_mul(tradeAmount, price))
                    filled = Precise.string_add(filled, tradeAmount)
                    remaining = Precise.string_sub(remaining, tradeAmount)
                if Precise.string_le(filled, '0'):
                    comparison['error'] = 'insufficient liquidity'
                    comparisons.append(comparison)
                    continue
                filledNumber = self.parse_number(filled)
                costNumber = self.parse_number(cost)
                priceNumber = None
                if filledNumber is not None and filledNumber > 0 and costNumber is not None:
                    priceNumber = costNumber / filledNumber
                slippage = None
                if (cowPrice is not None) and (priceNumber is not None) and (cowPrice != 0):
                    slippage = (priceNumber - cowPrice) / cowPrice
                comparison = self.extend(comparison, {
                    'available': filledNumber,
                    'cost': costNumber,
                    'price': priceNumber,
                    'slippage': slippage,
                    'remaining': self.parse_number(remaining),
                })
            except Exception as error:
                comparison['error'] = (isinstance(error, error.message if Error)) else self.json(error)
            comparisons.append(comparison)
        return {
            'symbol': symbol,
            'amount': amount,
            'price': self.parse_number(cowPrice),
            'buyAmount': self.parse_number(cowBuyAmount),
            'sellAmount': self.parse_number(effectiveAmount),
            'fee': self.parse_number(cowFee),
            'info': quoteResponse,
            'comparisons': comparisons,
        }

    async def wait_for_order(self, id: Str, symbol: Str = None, status: Str = None, params={}) -> Order:
        await self.load_markets()
        options = self.safe_value(self.options, 'waitForOrder', {})
        statuses = self.safe_value(options, 'statuses', ['closed', 'canceled', 'expired', 'rejected'])
        targetStatuses = statuses if (status is None) else [status]
        defaultPollingDelay = self.safe_integer(options, 'pollingDelay', 2000)
        defaultTimeout = self.safe_integer(options, 'timeout', 60000)
        pollingDelay = self.safe_integer(params, 'pollingDelay', defaultPollingDelay)
        timeout = self.safe_integer(params, 'timeout', defaultTimeout)
        fetchParams = self.omit(params, ['pollingDelay', 'timeout'])
        deadline = self.milliseconds() + timeout
        # eslint-disable-next-line no-constant-condition
        while(True):
            order = await self.fetch_order(id, symbol, fetchParams)
            orderStatus = self.safe_string(order, 'status')
            if self.in_array(orderStatus, targetStatuses):
                return order
            if self.milliseconds() > deadline:
                raise InvalidOrder(self.id + ' waitForOrder() timed out waiting for order ' + id + ' to reach status ' + ','.join(targetStatuses))
            await self.sleep(pollingDelay)

    def handle_errors(self, httpCode: Int, reason: str, url: str, method: str, headers: dict, body: str, response, requestHeaders, requestBody):
        if response is None:
            return
        errorType = self.safe_string(response, 'errorType')
        if errorType is not None:
            description = self.safe_string(response, 'description')
            feedback = self.id + ' ' + (description is body if None else description)
            errors = {
                'DuplicatedOrder': InvalidOrder,
                'OrderAlreadyExists': InvalidOrder,
                'InvalidOrder': InvalidOrder,
                'InsufficientFee': InvalidOrder,
                'InsufficientFunds': InsufficientFunds,
                'UnknownOrder': OrderNotFound,
                'OrderNotFound': OrderNotFound,
                'OrderExpired': OrderNotFound,
                'InvalidSignature': AuthenticationError,
                'UnsupportedSellToken': BadSymbol,
                'UnsupportedBuyToken': BadSymbol,
                'UnsupportedSigningScheme': AuthenticationError,
                'InvalidAppData': BadRequest,
                'SellAmountDoesNotCoverFee': InvalidOrder,
                'SlippageTooLarge': InvalidOrder,
                'NoLiquidity': InvalidOrder,
            }
            Exception = self.safe_value(errors, errorType, ExchangeError)
            raise Exception(feedback)
        errorsList = self.safe_list(response, 'errors')
        if errorsList is not None:
            for i in range(0, len(errorsList)):
                error = errorsList[i]
                type = self.safe_string(error, 'errorType')
                if type is not None:
                    description = self.safe_string(error, 'description')
                    feedback = self.id + ' ' + (description is self.json(error) if None else description)
                    errors = {
                        'DuplicatedOrder': InvalidOrder,
                        'InvalidOrder': InvalidOrder,
                        'InsufficientFee': InvalidOrder,
                        'InsufficientFunds': InsufficientFunds,
                        'UnsupportedSellToken': BadSymbol,
                        'UnsupportedBuyToken': BadSymbol,
                        'NoLiquidity': InvalidOrder,
                    }
                    Exception = self.safe_value(errors, type, ExchangeError)
                    raise Exception(feedback)
        status = self.safe_string(response, 'status')
        if (status is not None) and (status != 'success') and (status != 'ok'):
            description = self.safe_string(response, 'description')
            feedback = self.id + ' ' + (description is body if None else description)
            raise ExchangeError(feedback)
